// Fn Bytecode is the intermediate representation of Fn programs.
// It is generated by the code generator and executed by the
// virtual machine.

#pragma once

#include <cstdint> // uintXX_t
#include <vector> // std::vector
#include <array> // std::array
#include <initializer_list> // std::initializer_list

#include "src/number.h"

namespace fn { namespace bytecode {

  // The smallest unit of instruction.
  // (Note that instructions are at least this size,
  // but are usually more.)
  typedef char CodeByte;

  // The first byte of any instruction is an OpCode.
  // It tells the VM the operation to perform.
  typedef CodeByte OpCode;

  #define FN_OP_FALSE (fn::bytecode::OpCode)(0)
  #define FN_OP_TRUE (fn::bytecode::OpCode)(1)
  #define FN_OP_AND (fn::bytecode::OpCode)(2)
  #define FN_OP_OR (fn::bytecode::OpCode)(3)
  #define FN_OP_NOT (fn::bytecode::OpCode)(4)

  #define FN_OP_NUMBER (fn::bytecode::OpCode)(5)
  #define FN_OP_MULTIPLY (fn::bytecode::OpCode)(6)
  #define FN_OP_DIVIDE (fn::bytecode::OpCode)(7)
  #define FN_OP_ADD (fn::bytecode::OpCode)(8)
  #define FN_OP_SUBTRACT (fn::bytecode::OpCode)(9)

  #define FN_OP_DEF (fn::bytecode::OpCode)(12)
  #define FN_OP_CALL (fn::bytecode::OpCode)(13)
  #define FN_OP_RETURN_LAST (fn::bytecode::OpCode)(14)

  #define FN_OP_STRING (fn::bytecode::OpCode)(10)

  #define FN_OP_EQ (fn::bytecode::OpCode)(15)

  #define FN_OP_LOAD (fn::bytecode::OpCode)(11)


  // Values in the VM are indexed.
  // References to values are given by this type.
  // TODO: Expand to 16-bit.
  typedef CodeByte ValueIndex;
  #define VALUE_INDEX_BYTES (1)
  #define MAX_VALUES (UINT8_MAX)

  // Instruction references are given by this type.
  // TODO: Expand to 32-bit.
  typedef CodeByte InstructionIndex;
  #define INSTRUCTION_INDEX_BYTES (1)
  #define MAX_INSTRUCTIONS (UINT8_MAX)

  // A CodeBlob is a contiguous list of CodeBytes.
  class CodeBlob {
  private:
    std::vector<CodeByte> bytes;

  public:

    CodeBlob() {
      this->bytes = std::vector<CodeByte>{};
    }

    CodeBlob(std::initializer_list<CodeByte> bytes) {
      this->bytes = std::vector<CodeByte>(bytes);
    }

    // Special constructor taking a list of CodeBlobs.
    // Stores the concatenation of all given CodeBlobs.
    CodeBlob(std::initializer_list<CodeBlob> blobs) : CodeBlob() {
      for (auto argBlob : blobs) {
        this->append(argBlob);
      }

    }

    // Create a CodeBlob from an array.
    template<size_t S>
    CodeBlob(std::array<CodeByte, S> bytes) {
      this->bytes = std::vector<CodeByte>(bytes.begin(), bytes.end());
    }

    // Copies one blob to the end of another.
    void append(CodeBlob blob) {
      this->bytes.reserve(blob.size());
      this->bytes.insert(this->bytes.end(), blob.bytes.begin(), blob.bytes.end());
    }

    // Use asBytes() and size() to work with the bytes directly
    // as a C-array.
    CodeByte* asBytes() { return this->bytes.data(); }

    size_t size() const { return this->bytes.size(); }

  };

  // Instruction Generators
  CodeBlob iFalse();
  CodeBlob iTrue();
  CodeBlob iAnd(ValueIndex first, ValueIndex second);
  CodeBlob iOr(ValueIndex first, ValueIndex second);
  CodeBlob iNot(ValueIndex idx);

  CodeBlob iNumber(Number number);
  CodeBlob iNumber(Coefficient coefficient, Exponent exponent);
  CodeBlob iMultiply(ValueIndex first, ValueIndex second);
  CodeBlob iDivide(ValueIndex first, ValueIndex second);
  CodeBlob iAdd(ValueIndex first, ValueIndex second);
  CodeBlob iSubtract(ValueIndex first, ValueIndex second);

  CodeBlob iDefHeader(InstructionIndex length);
  CodeBlob iCall(ValueIndex index);
  CodeBlob iReturnLast();

  CodeBlob iEq(ValueIndex first, ValueIndex second);

  CodeBlob iLoad(ValueIndex index);

}}
